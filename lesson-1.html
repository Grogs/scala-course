<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/sky.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Mermaid -->
    <link rel="stylesheet" href="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.css">
    <style>
      .mermaid .label  {
        color: white;
      }

      .node rect {
        fill: #005894;
      }
    </style>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
    <style>
      .reveal .footer {
        position: absolute;
        bottom: 1em;
        left: 1em;
        font-size: 0.7em;
      }

      /*Theme overrides*/
      .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
        text-transform: none;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class='footer'>
        <a href="https://grogs.github.io/scala-course">grogs.github.io/scala-course</a>
      </div>
      <div class="slides">
        <section data-markdown data-separator="^~~~~" data-separator-vertical="^~" data-notes="^Note:">
          <script type="text/template">

## Full Stack Scala  

### Lesson 1

~
Before we start, let's kick off some downloads.

Note:
* This will take a while!
~
Download IntelliJ

https://www.jetbrains.com/idea/

Note: we'll get round to installing it later
~
Checkout this git project:  

`git clone https://github.com/grogs/scala-course`

Note:
* is everyone a little familiar with git
* does everyone have git installed?
~
Start downloading the project's dependencies

```
cd scala-course
./sbt compile
```
~~~~

## Introductions
* Who are you?  
* What do you do here at Expedia?  
* What are you looking to get from the course?

Note:
* Whilst that's churning away in the background, let's continue.

~~~~

## Course Plan
* Learn to build web apps with Scala.
* Play Framework for backend
* Scala.js on the frontend
* You should be able to go away and build your own rich web applications

Note:
* Instead, we'll focus on using Scala/Play/Scala.js as a productive platform to build webapps end to end.
* We'll use Play on the backend because it's really quick to get up and running, and provides a really nice developer experience.
* We'll learn more about that next week.
* We're going to use Scala.js on the frontend... Because I think Scala is cool and you should use it in the browser. Also because there are some real advantages to using the same language across the frontend and backend.
* Again, we'll learn more about this next week.

~

Today let's start with an introduction to Scala itself

~
Starting with some history of where it came from

~
- __1996__ Java 1.0 released

Note:
To talk about the history of Scala, we've got to talk about Java
~
- __1997__ Pizza released by Martin Odersky and Philip Wadler
  * Added some new features to Java:
    * _polymorphism (AKA generics)_
    * _algebraic types_ (AKA case classes)
    * _high order functions_ (examples map, filter)

Note:
* A year later, Martin Oderky (Scala's creator) and Philip Wadler released Pizza.
* This was a superset of Java and compiled down to Java. 
~
- __1998__ GJ released by Odersky, Wadler et al. 
  * Compiled to JVM bytecode. 
  * Kept generics (using type erasure), dropped algebraic types and higher order functions

Note:
* The next year, they released GJ. This compiled directly to JVM bytecode. And it dropped a number of the cool features from Pizza and later Scala.
~
- __2000__ Sun Microsystems adopts GJ as `javac` in JDK 1.3
  * With generics removed

<div><div class="mermaid">
  graph TB;
  java1["Java 1.0"]--> d1[" "] 
  d1 --> d2[" "]
  pizza["Pizza"] --> gj["GJ"]
  java1.3["Java 1.3"]
  d2 --> java1.3
  gj --> java1.3
  style d1 height:0
  style d2 height:0
</div></div>

Note:
* A couple of years later, Sun actually adopted GJ as the Java compiler.
* But they remove generics. 
~
__2004__ Java 1.5 released, with generics from GJ 
<div><div class="mermaid">
  graph TB;
  java1["Java 1.0"]--> d1[" "] 
  d1 --> d2[" "]
  pizza["Pizza"] --> gj["GJ"]
  java1.3["Java 1.3"] --> java1.5["Java 1.5"]
  d2 --> java1.3
  gj --> java1.3
  gj --> java1.5
  style d1 height:0
  style d2 height:0
</div></div>     

Note:
A couple more years later, Java incorporated Generics.
~
### Functional Programming

Note:
 - These features in the Pizza language - generics, case classes, higher order functions - all came from functional programming, which itself has a long history before Java even started.
 - It dates all the way back to __Lambda calculus__ developed in 1930s
 - __Lisp__, developed in 1950s, is essentially a language built around the ideas of lambda calculous 
 - __ML__ (an acronym for Meta Language) developed in 1970s. This was Lisp with types. The types in ML languages are automatically infered (similar to Java 10's local type inference), and ensure type safety â€“ there is a formal proof that a well-typed ML program does not cause runtime type errors.
 - __Haskell__ version 1.0 was released in 1990. Haskell is a ML derivative that is more functionally pure - you can't have side effects. (Well of course you can, you can look up the IO monad)

~
Odersky develops __Funnel__ 1999-2001
  - compiled to JVM bytecode
  - blended OO and FP

Note:
* After working on Pizza and GJ, whilst Java would adopting GJ as the Java compiler, Odersky built Funnel.
* Precursor to Scala.
~
__2004__ Scala publicly released
  * Blended OO and FP
  * Written in Java  
Note:
* A couple years after that, in the same year Java got generics, Scala was first publically released. 
* It included features for Pizza like case classes and higher order functions. And more, like pattern matching, better type inference, etc.
~
__2006__ Scala 2.x first released

This is the current major version of Scala.

Note:
We're up to 2.12 with 2.13 on the way.
It was bootstrapped (written in Scala)
~
## Dotty
### AKA Scala 3
Note:
* Over the last 5 years, Odersky and his students at EPFL have been working on Dotty.
* Simplifies the theory underlying the language, and the compiler itself.
* It should give us faster compilation, and much cleaner compiler codebase to evolve on in future.
* It also includes TASTY trees - which is a technique to solve the binary compatibility issues that have been a pain point with Scala.
* There's a strong focus on making the transition very smooth. Odersky doesn't want the migration to be a huge issue like Python 2 to 3 was.
~
## Why use Scala?
~
### Better Java

Note:
* When I started using Scala at work 6 years ago, it was mainly interesting as a "better Java".
* For two reasons I think: it is more concise that Java, and the FP influences were seen as better.
* The Java community had already been embracing immutability (but awkwardly), and projects to provide nicer collections APIs.
* e.g. Guava had/has things like `List.transform` which mapped over collections
* But if I'm honest, Kotlin is very strong competition now IF you just want a "better Java". You get case classes, nice collection API etc.
~
### Performance / Scalability; yet with a concise syntax.

Note:
* This is one of the big motivations/reasons for myself and my team here at HCOM. 
* This could be a course on its own.
* For people from a Python/Ruby background Scala can just be a concise syntax with Java's performance.
* There's a bunch of libraries and whole ecosystems for concurrency and asynchronous programming now in Scala.
* Powerful Futures which I would argue are much nicer to work with than Java's CompletableFuture. Alternate implementations of Futures, and there are other things kind of like Futures but different.
* Such as Akka Actors which implement Erlang Actor model on the JVM.
* Stream processing libraries like akka-streams, monix, fs2. For Java you've got RxJava, and the Java 9 Flow API... In my opinion RxJava is not pleasant to work with compared with Scala alternatives.
~
### Datascience and Machine Learning ecosystem

Note:
* Spark is a big player here.
* The JVM seems to dominate in the big data world. I think as data science and ML have started happening on big data, you have datascientists with Python or R background, and they appreciate a more concise yet still performant syntax over Java.
* Also Functional programming is useful/imperative once you start doing distributed processing etc. MapReduce is basically just the concept of Monoid from Category Theory/Functional Programming.
~
### Static functional programming 

Note:
* Concurrent and asychronous programming are both a bit of a nightmare if you don't at least embrace immutability. 
* But FP in Scala can be a lot more than that!
* There are a number of library that implement or incorporate concepts from Category Theory. (Which basically just aims to make your code easier to reason about and compose.)
* In Scala we can do a lot with types. If you adopt the functional stuff in the Scala ecosystem, you can really have a lot more guarantees about your code at compile time.

~~~~
### Running our skeleton project
~
Have IntelliJ and SBT finished downloading?
~

Install IntelliJ, and the Scala plugin.  
  
Open the project's build.sbt in IntelliJ.  
  
Hit Cmd+F9 to build the project. Any errors?

Note:
* Ctrl+F9 on Windows.

~

Run the app with:

`./sbt run`

Then browse to http://localhost:9000

Note: Any errors in the terminal
~
We're done.  
          </script>         
        </section>
      </div>
    </div>

<!-- Now let's look at some Scala code
          ~
          Starting with the obligatory hello world

          ```
          object Main {
            def main(args: Array[String]): Unit = {
              println("Hello world!")
            }
          }
          ``` 

          Note:
          * No semicolons
          * No `public` access modifier
          * Methods/functions definition starts with `def`
          * No explicit return statement
          * Types are written after identifiers
          * 'Unit' type. 
          * We could omit `:Unit` and rely on type inference
          * We can omit the braces around the method definition
          * Like variable assignment, methods declaration has `=`
          
          Whirlwind tour of Scala:
          * Type inference.
          * everything's an object
          * `if` and `for` are expressions not statements
            * Scala `if` is like Java's ternary operator 
          * Case classes / ADT (including traits)
            * Constructor, fields are public and immutable
            * apply method on combanion object
            * Hashcode/equals/toString
            * copy method
            * Pattern matching
          * Collections
            * Combinators (+ type inference)
            * pattern matching in assignment
          * For comprehensions
            * map / flatMap / filter
            * pattern matching
          * Futures
            * ExecutionContext is your threadpool
            * for comprehensions
 -->

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,
        // showNotes: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>

    <!-- Mermaid -->
    <script src="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
  </body>
</html>
